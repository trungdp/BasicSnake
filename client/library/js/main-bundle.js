/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n//Ở đây ta tạo ra bộ khung chứa game\nvar canvas = document.getElementById('game');\nvar context = canvas.getContext('2d');\n\n\nconst defaultLength = 4;\nvar gameTimer = 0;\nvar bigAppleTimer = 0;\nvar grid = 30;\nvar level = 1;\nvar nameImage = './library/images/yellow.png';\nvar snakeImage ;\nvar scale = 3;\nvar bigAppleImage = loadImages(['./library/images/big-apple.png'])[0]; \nvar partImage = {\n    headUp:     {x:3 * 64,y:0 * 64},\n    headDown:   {x:4 * 64,y:1 * 64},\n    headRight:  {x:4 * 64,y:0 * 64},\n    headLeft:   {x:3 * 64,y:1 * 64},\n    tailUp:     {x:3 * 64,y:2 * 64},\n    tailDown:   {x:4 * 64,y:3 * 64},\n    tailRight:  {x:4 * 64,y:2 * 64},\n    tailLeft:   {x:3 * 64,y:3 * 64},\n    apple:      {x:0 * 64,y:3 * 64},\n    horiBody:   {x:1 * 64,y:0 * 64},\n    vetiBody:   {x:2 * 64,y:1 * 64},\n    topLeft:    {x:2 * 64,y:2 * 64},\n    topRight:   {x:0 * 64,y:1 * 64},\n    botLeft:    {x:2 * 64,y:0 * 64},\n    botRight:   {x:0 * 64,y:0 * 64}\n}\n// khởi tạo đối tượng rắn là 1 ô vuông\n\nvar snake = {\n    x: 5 * grid,\n    y: 5 * grid,\n    dx: grid,\n    dy: 0,\n    cells: [],\n    maxCells: defaultLength\n};\n\nvar count = 0;\nvar apple = {\n    x: 8 * grid,\n    y: 8 * grid,\n    width: grid,\n    height: grid\n};\n\nvar bigApple = {\n    x: -1000,\n    y: -1000,\n    width: grid * 2,\n    height: grid * 2\n};\n\nvar ar = new Array(37, 38, 39, 40);\n\nfunction speedFromLevel() {\n    switch (level) {\n        case 2:     return 120;\n        case 3:     return 105;\n        case 4:     return 90;\n        case 5:     return 75;\n        case 6:     return 60;\n        case 7:     return 50;\n        default:    return 135;\n    }\n}\n\nfunction allEqual(a,b,c){\n    return a == b && b == c\n}\n\nfunction bigAppleScoreFromLevel() {\n    return 10 * level;\n}\n\nfunction getRandomInt(min, max) {\n    return Math.floor(Math.random() * (max - min)) + min;\n}\n\nfunction inscreateScore(addingScore) {\n    const newScore = Number($(\"#user-score\").text()) + addingScore;\n    $(\"#user-score\").text(newScore.toString());\n}\n\nfunction resetScore() {\n    $(\"#user-score\").text(0);\n}\n\nfunction rowColNumber() {\n    return {\n        row: parseInt($('#game').height() / grid),\n        col: parseInt($('#game').width() / grid)\n    }\n}\n\nfunction newApple() {\n    apple.x = getRandomInt(0, rowColNumber().col) * grid;\n    apple.y = getRandomInt(0, rowColNumber().row) * grid;\n}\n\nfunction newBigApple() {\n    bigApple.x = getRandomInt(0, rowColNumber().col - 1) * grid;\n    bigApple.y = getRandomInt(0, rowColNumber().row - 1) * grid;\n}\n\nfunction hideBigApple() {\n    bigApple.x = -1000;\n    bigApple.y = -1000;\n}\n\nfunction resetSnake() {\n    snake = {\n        x: 5 * grid,\n        y: 5 * grid,\n        dx: grid,\n        dy: 0,\n        cells: [],\n        maxCells: defaultLength\n    };\n    newApple();\n    snakeImage = loadImages([nameImage])[0];\n\n    var resetTimer = setInterval(() => {\n        context.clearRect(0, 0, canvas.width, canvas.height);\n        snake.x += snake.dx;\n        snake.y += snake.dy;\n\n        snake.cells.unshift({\n            x: snake.x,\n            y: snake.y\n        });\n\n        if (snake.cells.length > snake.maxCells) {\n            snake.cells.pop();\n        }\n        drawBackground();\n        drawSnake();\n\n        if ((snake.cells.length == snake.maxCells)) {\n            clearInterval(resetTimer);\n        }\n    }, 0)\n}\n\nfunction countDown() {\n    snake.cells.forEach(function (cell, index) {\n        for (var i = index + 1; i < snake.cells.length; i++) {\n            if (cell.x === snake.cells[i].x && cell.y === snake.cells[i].y) {\n                resetSnake();\n                resetScore();\n                break;\n            }\n        }\n    });\n    var time = 3;\n    $('#noti-text').text('Ready');\n    $('#start-button').addClass('disabled');\n    $('.game-control').addClass('disabled');\n    $('#start-button').text((time).toString());\n    \n    gameTimer = setInterval(() => {\n        time -= 1;\n        if (time == 0) {\n            $('#start-button').text();\n            $('.start-game').hide();\n            $('#game').removeClass('canvas-blur');\n            clearInterval(gameTimer);\n            startGame();\n        } else {\n            $('#start-button').text((time).toString())\n        }\n    }, 850);\n};\n\nfunction snakeDeath() {\n    clearInterval(gameTimer);\n    clearInterval(bigAppleTimer);\n    gameOver();\n}\n\nfunction startGame() {\n    gameTimer = setInterval(() => {\n        context.clearRect(0, 0, canvas.width, canvas.height);\n        snake.x += snake.dx;\n        snake.y += snake.dy;\n\n        // khi snake đụng tường sẽ chạy lại từ edge đối diện\n        if (snake.x < 0) {\n            snake.x = canvas.width - grid;\n        } else if (snake.x >= canvas.width) {\n            snake.x = 0;\n        }\n\n        if (snake.y < 0) {\n            snake.y = canvas.height - grid;\n        } else if (snake.y >= canvas.height) {\n            snake.y = 0;\n        }\n\n        // Phương thức unshift sẽ thêm một hoặc nhiều phần tử vào đầu mảng\n        snake.cells.unshift({\n            x: snake.x,\n            y: snake.y\n        });\n        // thêm 1 ô vuông phía trc thì phải remove 1 cái phía sau để snake move dc.\n        if (snake.cells.length > snake.maxCells) {\n            snake.cells.pop();\n        }\n        drawBackground();\n        drawApple();\n        drawSnake();\n    }, speedFromLevel())\n}\n\nvar x, i, j, selElmnt, a, b, c;\n/*look for any elements with the class \"custom-select\":*/\nx = document.getElementsByClassName(\"custom-select\");\nfor (i = 0; i < x.length; i++) {\n    selElmnt = x[i].getElementsByTagName(\"select\")[0];\n    /*for each element, create a new DIV that will act as the selected item:*/\n    a = document.createElement(\"DIV\");\n    a.setAttribute(\"class\", \"select-selected\");\n    a.innerHTML = selElmnt.options[selElmnt.selectedIndex].innerHTML;\n    x[i].appendChild(a);\n    /*for each element, create a new DIV that will contain the option list:*/\n    b = document.createElement(\"DIV\");\n    b.setAttribute(\"class\", \"select-items select-hide\");\n    for (j = 1; j < selElmnt.length; j++) {\n        /*for each option in the original select element,\n        create a new DIV that will act as an option item:*/\n        c = document.createElement(\"DIV\");\n        c.innerHTML = selElmnt.options[j].innerHTML;\n        c.addEventListener(\"click\", function (e) {\n            /*when an item is clicked, update the original select box,\n            and the selected item:*/\n            var y, i, k, s, h;\n            s = this.parentNode.parentNode.getElementsByTagName(\"select\")[0];\n            h = this.parentNode.previousSibling;\n            for (i = 0; i < s.length; i++) {\n                if (s.options[i].innerHTML == this.innerHTML) {\n                    s.selectedIndex = i;\n                    h.innerHTML = this.innerHTML;\n                    y = this.parentNode.getElementsByClassName(\"same-as-selected\");\n                    for (k = 0; k < y.length; k++) {\n                        y[k].removeAttribute(\"class\");\n                    }\n                    this.setAttribute(\"class\", \"same-as-selected\");\n                    break;\n                }\n            }\n            h.click();\n        });\n        b.appendChild(c);\n    }\n    x[i].appendChild(b);\n    a.addEventListener(\"click\", function (e) {\n        /*when the select box is clicked, close any other select boxes,\n        and open/close the current select box:*/\n        e.stopPropagation();\n        closeAllSelect(this);\n        this.nextSibling.classList.toggle(\"select-hide\");\n        this.classList.toggle(\"select-arrow-active\");\n    });\n}\n\nfunction closeAllSelect(elmnt) {\n    var x, y, i, arrNo = [];\n    x = document.getElementsByClassName(\"select-items\");\n    y = document.getElementsByClassName(\"select-selected\");\n    for (i = 0; i < y.length; i++) {\n        if (elmnt == y[i]) {\n            arrNo.push(i)\n        } else {\n            y[i].classList.remove(\"select-arrow-active\");\n        }\n    }\n    for (i = 0; i < x.length; i++) {\n        if (arrNo.indexOf(i)) {\n            x[i].classList.add(\"select-hide\");\n        }\n    }\n    level = parseInt(document.getElementById('level-select').value);\n}\n\nfunction countDownBigAppleScore() {\n    var val = 100;\n    var speed = speedFromLevel();\n    $('.option-game').css('visibility', 'visible');\n    bigAppleTimer = setInterval(function () {\n        val = val - 2;\n        $('[type=\"range\"]').val(val);\n        $('[type=\"range\"]').css('filter', 'hue-rotate(-' + val + 'deg)');\n        $('#big-apple-score').text(parseInt(val * bigAppleScoreFromLevel() / 100));\n        if (val <= 0) {\n            clearInterval(bigAppleTimer);\n            hideBigApple();\n            $('.option-game').css('visibility', 'hidden');\n        }\n    }, speed);\n};\n\n//bắt sự kiện bàn phím ấn xuống\ndocument.addEventListener('keydown', function (e) {\n    if (e.which === 37 && snake.dx === 0 && snake.dy != 0) {\n        snake.dx = -grid;\n        snake.dy = 0;\n    } else if (e.which === 38 && snake.dy === 0 && snake.dx != 0) {\n        snake.dy = -grid;\n        snake.dx = 0;\n    } else if (e.which === 39 && snake.dx === 0 && snake.dy != 0) {\n        snake.dx = grid;\n        snake.dy = 0;\n    } else if (e.which === 40 && snake.dy === 0 && snake.dx != 0) {\n        snake.dy = grid;\n        snake.dx = 0;\n    }\n});\n\n\nfunction loadImages(imagefiles) { // LoadImage\n    loadcount = 0;\n    loadtotal = imagefiles.length;\n    preloaded = false; // Load the images\n    var loadedimages = [];\n    for (var i=0; i<imagefiles.length; i++) { // Create the image object\n        var image = new Image();\n        \n        image.onload = function () {\n            loadcount++;\n            if (loadcount == loadtotal) { // Done loading\n                preloaded = true;\n            }\n        };\n        image.src = imagefiles[i];\n        loadedimages[i] = image;\n    }\n    \n    // Return an array of images\n    return loadedimages;\n}\n\nfunction drawBackground(){\n    var scale = 2;\n    var size = scale * grid;\n    for (var c = 0; c < rowColNumber().col / scale ; c++){\n        for (var r = 0; r < rowColNumber().row / scale ; r++){\n            context.fillStyle = (c+r) % 2 == 0 ? \"#d3eec0\" : \"#94dad7\";\n            context.fillRect(c * size, r * size, size, size);\n        }\n    }\n}\n\nfunction drawApple(){\n    context.drawImage(snakeImage, partImage.apple.x, partImage.apple.y, 64, 64, apple.x, apple.y, grid, grid);\n    if (bigApple.x > 0 && bigApple.y > 0){\n        scale = scale == 3 ? 0 : 3;\n        context.drawImage(bigAppleImage, 0, 0, 128, 128, \n            bigApple.x + scale, bigApple.y + scale, bigApple.width - 2 * scale , bigApple.height  - 2 * scale);\n    } \n}\n\nfunction drawSnake() {\n    snake.cells.forEach(function (cell, index) {\n        cell.center = {\n            x: cell.x + grid / 2,\n            y: cell.y + grid / 2\n        }\n        var x = cell.center.x; var y = cell.center.y;\n        \n        var prevSegment = snake.cells[index-1], nextSegment = snake.cells[index+1];\n        var segmentType = partImage.apple;\n        \n        if (index == 0 && nextSegment) { // Head; Determine the correct image\n            var nextSegmentX = nextSegment.center.x; \n            var nextSegmentY = nextSegment.center.y;\n\n            if        (y < nextSegmentY) { // Up\n                segmentType = nextSegmentY - y == grid ? partImage.headUp : partImage.headDown\n            } else if (x > nextSegmentX) { // Right\n                segmentType = x - nextSegmentX == grid ? partImage.headRight : partImage.headLeft\n            } else if (y > nextSegmentY) { // Down\n                segmentType = y - nextSegmentY == grid ? partImage.headDown : partImage.headUp\n            } else if (x < nextSegmentX) { // Left\n                segmentType = nextSegmentX - x == grid ? partImage.headLeft : partImage.headRight\n            }\n        } else if (index == snake.cells.length - 1 && prevSegment) {\n            var prevSegmentX = prevSegment.center.x; // Previous segment\n            var prevSegmentY = prevSegment.center.y;\n\n            if        (prevSegmentY < y) { // Up\n                segmentType = y - prevSegmentY == grid ? partImage.tailUp : partImage.tailDown\n            } else if (prevSegmentX > x) { // Right\n                segmentType = prevSegmentX - x == grid ? partImage.tailRight : partImage.tailLeft\n            } else if (prevSegmentY > y) { // Down\n                segmentType = prevSegmentY - y == grid ? partImage.tailDown : partImage.tailUp\n            } else if (prevSegmentX < x) { // Left\n                segmentType = x - prevSegmentX == grid ? partImage.tailLeft : partImage.tailRight\n            }\n        } else if (prevSegment && nextSegment){ // Body; Determine the correct image\n            var prevSegmentX = prevSegment.center.x; // Previous segment\n            var prevSegmentY = prevSegment.center.y;\n            var nextSegmentX = nextSegment.center.x; // Next segment\n            var nextSegmentY = nextSegment.center.y;\n\n            if (prevSegmentX < x && nextSegmentX > x || nextSegmentX < x && prevSegmentX > x ) { // Horizontal Left-Right\n                segmentType = partImage.horiBody;\n            } else if (prevSegmentY < y && nextSegmentY > y || nextSegmentY < y && prevSegmentY > y) { // Vertical Top-Bottom\n                segmentType = partImage.vetiBody;\n            } else if ((prevSegmentX < x && nextSegmentY > y && allEqual(x - prevSegmentX, nextSegmentY - y, grid)) ||\n                        (nextSegmentX < x && prevSegmentY > y && allEqual(x - nextSegmentX, prevSegmentY - y, grid))) { // Angle Left-Down\n                segmentType = partImage.botLeft;\n            } else if ((prevSegmentX < x && nextSegmentY > y || nextSegmentX < x && prevSegmentY > y ) && (Math.abs(prevSegmentY - y)  > grid || Math.abs(nextSegmentY - y)  > grid)) {\n                segmentType = partImage.topLeft;\n            }  else if ((prevSegmentX < x && nextSegmentY > y || nextSegmentX < x && prevSegmentY > y ) && (Math.abs(x - nextSegmentX) > grid || Math.abs(x - prevSegmentX) > grid)) {\n                segmentType = partImage.botRight; \n            } else if ((prevSegmentY < y && nextSegmentX < x || nextSegmentY < y && prevSegmentX < x) && \n                        (allEqual(y - prevSegmentY, x - nextSegmentX, grid) || allEqual(y - nextSegmentY, x - prevSegmentX, grid)))  { // Angle Top-Left\n                segmentType = partImage.topLeft;\n            } else if ((prevSegmentY < y && nextSegmentX < x || nextSegmentY < y && prevSegmentX < x) && (Math.abs(y - nextSegmentY) > grid || Math.abs(y - prevSegmentY) > grid)){\n                segmentType = partImage.botLeft \n            } else if ((prevSegmentY < y && nextSegmentX < x || nextSegmentY < y && prevSegmentX < x) && (Math.abs(x - nextSegmentX) > grid || Math.abs(x - prevSegmentX > grid))){\n                segmentType = partImage.topRight \n            } else if ((prevSegmentX > x && nextSegmentY < y || nextSegmentX > x && prevSegmentY < y) && \n                        (allEqual(prevSegmentX - x, y - nextSegmentY, grid) || allEqual(nextSegmentX - x, y - prevSegmentY, grid))) { // Angle Top-Right\n                segmentType = partImage.topRight \n            } else if ((prevSegmentX > x && nextSegmentY < y || nextSegmentX > x && prevSegmentY < y) && (Math.abs(prevSegmentX - x) > grid || Math.abs(nextSegmentX - x) > grid)){\n                segmentType = partImage.topLeft\n            } else if ((prevSegmentX > x && nextSegmentY < y || nextSegmentX > x && prevSegmentY < y) && (Math.abs(y - prevSegmentY) > grid || Math.abs(y - nextSegmentY) > grid)){\n                segmentType = partImage.botRight; \n            } else if ((prevSegmentY > y && nextSegmentX > x || nextSegmentY > y && prevSegmentX > x) && \n                        (allEqual(prevSegmentY - y, nextSegmentX - x, grid) || allEqual(nextSegmentY - y, prevSegmentX - x, grid))) { // Angle Bot-Right\n                segmentType = partImage.botRight;\n            } else if ((prevSegmentY > y && nextSegmentX > x || nextSegmentY > y && prevSegmentX > x) && (Math.abs(prevSegmentX - x) > grid || Math.abs(nextSegmentX - x) > grid)){\n                segmentType = partImage.botLeft \n            } else if ((prevSegmentY > y && nextSegmentX > x || nextSegmentY > y && prevSegmentX > x) && (Math.abs(nextSegmentY - y) > grid || Math.abs(prevSegmentY - y) > grid)){\n                segmentType = partImage.topRight \n            } else if (prevSegmentX > nextSegmentX && nextSegmentX > x || x > prevSegmentX && prevSegmentX > nextSegmentX ||\n                        nextSegmentX > prevSegmentX && prevSegmentX > x || x > nextSegmentX && nextSegmentX > prevSegmentX ) {\n                segmentType = partImage.horiBody;\n            } else if (prevSegmentY > nextSegmentY && nextSegmentY > y || y > prevSegmentY && prevSegmentY > nextSegmentY ||\n                        nextSegmentY > prevSegmentY && prevSegmentY > y || y > nextSegmentY && nextSegmentY > prevSegmentY ) {\n                segmentType = partImage.vetiBody;\n            } \n        } \n        \n        context.drawImage(snakeImage, segmentType.x, segmentType.y, 64, 64, cell.x, cell.y, grid , grid );\n\n        //Eat Apple\n        if (apple.x <= cell.center.x && cell.center.x <= apple.x + apple.width &&\n            apple.y <= cell.center.y && cell.center.y <= apple.y + apple.height) {\n            snake.maxCells++;\n            newApple();\n            inscreateScore(level);\n\n            if (((snake.maxCells - defaultLength) != 0) && ((snake.maxCells - defaultLength) % 5 == 0)) {\n                newBigApple();\n                countDownBigAppleScore();\n            }\n        }\n\n        //Eat Big Apple\n        if (bigApple.x <= cell.center.x && cell.center.x <= bigApple.x + bigApple.width &&\n            bigApple.y <= cell.center.y && cell.center.y <= bigApple.y + bigApple.height) {\n            hideBigApple();\n            clearInterval(bigAppleTimer);\n            $('.option-game').css('visibility', 'hidden');\n            $('#big-apple-countdown').value = 100;\n            inscreateScore(parseInt($('#big-apple-score').text()));\n        }\n\n        if (index == 0) {\n            for (var i = index + 1; i < snake.cells.length; i++) { // va chạm \n                if (cell.center.x === snake.cells[i].center.x && cell.center.y === snake.cells[i].center.y) {\n                    snakeDeath();\n                    break;\n                }\n            }\n        }\n    });\n}\n\n$( \"#enter-name\" ).submit(function( event ) {\n    if ($(\"#input-name\" ).val()) {\n        closeEnterNameNav();\n        var name = $(\"#input-name\" ).val().split(' ')[0];\n        $(\"#top-navigation\").prepend('<li><a href=\"#\" onclick=\"openEnterNameNav()\" id=\"user-name\">' + name + '</a></li>');\n        $(\"#input-name\" ).val(\"\");\n        return;\n    }\n    $(\"#input-name-noti\").text( \"Please Enter Your Name\" ).show().fadeOut( 3000 );\n    event.preventDefault();\n});\n\n$('#form-feedback').submit(event => {\n    if (($('#feedback-area').val() != null && $('#feedback-area').val() != \"\") &&\n        ($(\"#user-name\").text() != null && $(\"#user-name\").text() != \"\")) {\n        $.post('/feedback', \n                { name: $(\"#user-name\").text(), content: $('#feedback-area').val() },\n            sendFeedback());\n    } else {\n        alert('Enter your name and feedback to send feedback!');\n    }\n    event.preventDefault();\n})\n\nfunction startDidTouch(){\n    if (document.getElementById('user-name')){\n        countDown();\n    } else {\n        openEnterNameNav();\n    }\n}\n\nfunction fillTopScore(data ) {\n    $(\"#table-body\").empty();\n    JSON.parse(data)['data'].forEach((item, index)=>{\n        var rank = index + 1;\n        switch (rank) {\n            case 1:\n                rank = '<img class=\"medal\" src=\"./library/images/gold-medal.svg\" alt=\"\"></img>';\n                $(\"#first-place-name\").text(item.name);\n                $(\"#best-score\").text(item.score);\n                break;\n            case 2:\n                rank = '<img class=\"medal\" src=\"./library/images/silver-medal.svg\" alt=\"\"></img>';\n                $(\"#second-place-name\").text(item.name);\n                break;\n            case 3:\n                rank = '<img class=\"medal\" src=\"./library/images/brone-medal.svg\" alt=\"\"></img>';\n                $(\"#third-place-name\").text(item.name);\n                break;\n            default: break;\n        }\n        $(\"#table-body\").append('<tr> ' + \n                                '<td>' + rank + '</td>' +\n                                '<td>' + item.name + '</td>' + \n                                '<td>' + item.score + '</td>' +\n                                '</tr>\")');\n    })\n}\n\nfunction postScore(data, status) {\n    fillTopScore(data);\n}\n\nfunction sendFeedback() {\n    alert('Thank you for your feedback ☺');\n    $('#feedback-area').val(\"\");\n}\n\nfunction gameOver(){\n    $('.start-game').show();\n    $('#start-button').text('New Game');\n    $('#noti-text').text('Game Over');\n    $('#game').addClass('canvas-blur');\n    $('.option-game').css('visibility', 'hidden');\n\n    $('#start-button').removeClass('disabled');\n    $('.game-control').removeClass('disabled');\n    $.post('/user-score', { name: $('#user-name').text(), score: parseInt($(\"#user-score\").text()) }, postScore);\n}\n\n$(document).ready(\n    function(){\n        document.addEventListener(\"click\", closeAllSelect);\n        resetSnake()\n        $('#game').addClass('canvas-blur');\n\n        $.get('/top-score', fillTopScore);\n    }\n)\n\n//# sourceURL=webpack:///./src/main.js?");

/***/ })

/******/ });